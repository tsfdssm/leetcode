/*
 * @lc app=leetcode.cn id=1093 lang=cpp
 *
 * [1093] 大样本统计
 *
 * https://leetcode-cn.com/problems/statistics-from-a-large-sample/description/
 *
 * algorithms
 * Medium (36.95%)
 * Likes:    24
 * Dislikes: 0
 * Total Accepted:    4.3K
 * Total Submissions: 11.6K
 * Testcase Example:  '[0,1,3,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]'
 *
 * 我们对 0 到 255 之间的整数进行采样，并将结果存储在数组 count 中：count[k] 就是整数 k 在样本中出现的次数。
 *
 * 计算以下统计数据:
 *
 *
 * minimum ：样本中的最小元素。
 * maximum ：样品中的最大元素。
 * mean ：样本的平均值，计算为所有元素的总和除以元素总数。
 * median ：
 *
 * 如果样本的元素个数是奇数，那么一旦样本排序后，中位数 median 就是中间的元素。
 * 如果样本中有偶数个元素，那么中位数median 就是样本排序后中间两个元素的平均值。
 *
 *
 * mode ：样本中出现次数最多的数字。保众数是 唯一 的。
 *
 *
 * 以浮点数数组的形式返回样本的统计信息 [minimum, maximum, mean, median, mode] 。与真实答案误差在 10^-5
 * 内的答案都可以通过。
 *
 *
 *
 * 示例 1：
 *
 *
 * 输入：count =
 * [0,1,3,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
 * 输出：[1.00000,3.00000,2.37500,2.50000,3.00000]
 * 解释：用count表示的样本为[1,2,2,2,3,3,3,3,3]。
 * 最小值和最大值分别为1和3。
 * 均值是(1+2+2+2+3+3+3+3) / 8 = 19 / 8 = 2.375。
 * 因为样本的大小是偶数，所以中位数是中间两个元素2和3的平均值，也就是2.5。
 * 众数为3，因为它在样本中出现的次数最多。
 *
 * 示例 2：
 *
 *
 * 输入：count =
 * [0,4,3,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
 * 输出：[1.00000,4.00000,2.18182,2.00000,1.00000]
 * 解释：用count表示的样本为[1,1,1,1,2,2,3,3,3,4,4]。
 * 最小值为1，最大值为4。
 * 平均数是(1+1+1+1+2+2+2+3+3+4+4)/ 11 = 24 / 11 =
 * 2.18181818…(为了显示，输出显示了整数2.18182)。
 * 因为样本的大小是奇数，所以中值是中间元素2。
 * 众数为1，因为它在样本中出现的次数最多。
 *
 *
 *
 *
 * 提示：
 *
 *
 * count.length == 256
 * 0 <= count[i] <= 10^9
 * 1 <= sum(count) <= 10^9
 * count 的众数是 唯一 的
 *
 *
 */

// @lc code=start
class Solution
{
public:
    vector<double> sampleStats(vector<int> &count)
    {
        double mini = -1, maxi, mean, mid, mod;
        int maxCnt = 0;
        int cnt = 0;
        for (int i = 0; i < 256; ++i)
        {
            if (0 == count[i])
                continue;
            double tmp = (double)i;
            if (-1 == mini)
                mini = tmp;
            maxi = tmp;
            mean += tmp * count[i];
            cnt += count[i];
            if (count[i] > maxCnt)
            {
                maxCnt = count[i];
                mod = tmp;
            }
        }
        mean /= (double)cnt;
        int mid_pos = (cnt + 1) / 2;
        int pos = 0;
        int i = 0;
        while (pos < mid_pos)
        {
            pos += count[i++];
        }
        double idx = (double)(i - 1);
        if (cnt & 1)
        {
            mid = idx;
        }
        else
        {
            if (pos == mid_pos)
            {
                while (count[i] == 0)
                    ++i;
                mid = (idx + i) / 2;
            }
            else
                mid = idx;
        }

        return {mini, maxi, mean, mid, mod};
    }
};
// @lc code=end
